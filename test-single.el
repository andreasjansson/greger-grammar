;;; test-single.el --- Test single case -*- lexical-binding: t -*-

(load-file "./greger-tree-sitter.el")

;; Helper function to read markdown content from corpus .txt files
(defun greger-read-corpus-file (name)
  "Read markdown content from a .txt corpus file, extracting only the input portion."
  (let ((file-path (format "./test/corpus/%s.txt" name)))
    (if (file-exists-p file-path)
        (with-temp-buffer
          (insert-file-contents file-path)
          (let ((content (buffer-string)))
            ;; Find the test content between the title header and the "---" separator
            (if (string-match "=\\{10,\\}\n.*?\n=\\{10,\\}\n\n\\(\\(?:.\\|\n\\)*?\\)\n---" content)
                (match-string 1 content)
              (error "Could not parse test file format: %s" file-path))))
      (error "Corpus file not found: %s" file-path))))

(let* ((markdown (greger-read-corpus-file "tool-use-multiple-params"))
       (expected '(((role . "user")
                    (content . "Search for python files containing 'def main'"))
                   ((role . "assistant")
                    (content . (((type . "tool_use")
                                 (id . "toolu_456")
                                 (name . "ripgrep")
                                 (input . ((pattern . "def main")
                                           (file-type . "py")
                                           (context-lines . 2)))))))
                   ((role . "user")
                    (content . (((type . "tool_result")
                                 (tool_use_id . "toolu_456")
                                 (content . "src/main.py:10:def main():\nsrc/utils.py:25:def main_helper():")))))
                   ((role . "assistant")
                    (content . "I found 2 matches for 'def main' in Python files."))))
       (actual (greger-tree-sitter-parse markdown)))
  (message "Expected length: %d" (length expected))
  (message "Actual length: %d" (length actual))
  (dotimes (i (length expected))
    (let ((exp-item (nth i expected))
          (act-item (nth i actual)))
      (message "Item %d equal: %s" i (equal exp-item act-item))
      (unless (equal exp-item act-item)
        (message "Expected item %d: %s" i exp-item)
        (message "Actual item %d: %s" i act-item)
        (let ((exp-content (cdr (assoc 'content exp-item)))
              (act-content (cdr (assoc 'content act-item))))
          (message "Content equal: %s" (equal exp-content act-content))
          (when (and (listp exp-content) (listp act-content))
            (message "Content lengths: exp=%d act=%d" (length exp-content) (length act-content))
            (dotimes (j (min (length exp-content) (length act-content)))
              (let ((exp-block (nth j exp-content))
                    (act-block (nth j act-content)))
                (message "Block %d equal: %s" j (equal exp-block act-block))
                (unless (equal exp-block act-block)
                  (message "Expected block %d: %s" j exp-block)
                  (message "Actual block %d: %s" j act-block)
                  (when (and (listp exp-block) (listp act-block))
                    (dolist (key '(type id name input))
                      (let ((exp-val (cdr (assoc key exp-block)))
                            (act-val (cdr (assoc key act-block))))
                        (message "Key %s: exp=%s act=%s equal=%s" key exp-val act-val (equal exp-val act-val))
                        (when (eq key 'input)
                          (message "Input comparison:")
                          (message "  Expected type: %s" (type-of exp-val))
                          (message "  Actual type: %s" (type-of act-val))
                          (when (and (listp exp-val) (listp act-val))
                            (message "  Expected length: %d" (length exp-val))
                            (message "  Actual length: %d" (length act-val))
                            (dotimes (k (min (length exp-val) (length act-val)))
                              (let ((exp-pair (nth k exp-val))
                                    (act-pair (nth k act-val)))
                                (message "    Pair %d: exp=%s act=%s equal=%s" k exp-pair act-pair (equal exp-pair act-pair))
                                (when (and (consp exp-pair) (consp act-pair))
                                  (message "      Car: exp=%s act=%s equal=%s type-exp=%s type-act=%s"
                                          (car exp-pair) (car act-pair) (equal (car exp-pair) (car act-pair))
                                          (type-of (car exp-pair)) (type-of (car act-pair)))
                                  (message "      Cdr: exp=%s act=%s equal=%s type-exp=%s type-act=%s"
                                          (cdr exp-pair) (cdr act-pair) (equal (cdr exp-pair) (cdr act-pair))
                                          (type-of (cdr exp-pair)) (type-of (cdr act-pair))))))))))))))))))))
